TOP 01

# php artisan make:mail nomedotipo
dentro de SeriesCreated temos uma classe qualquer, só que além de estender o Mailable ela também possui algumas traits que o Laravel nos fornece, 
no caso Queueable e SerializesModels.

A classe SeriesCreated estende um Mailable, isso significa que ela é enviável e possui alguns métodos como o view
também possui um construtor() para recebermos algum parâmetro que seja necessário, 
vamos utilizar e um build() que basicamente constrói o e-mail, define qual o template, se é preciso passar alguma coisa, 
se tiver alguma regra para criar esse e-mail podemos inserir nesse build(), mas isso normalmente não é necessário. 

Então, esse método view, return $this->view('view.name');, 
vai carregar um HTML e transformá-lo no e-mail que queremos enviar. Assim, 
vamos criar esse HTML em "resources > views" e em views vamos criar uma nova pasta de mail selecionando o botão direito do mouse nas opções "New > 
PHP File" e no campo "File name" inserir "mail/series-created.blade.php" que vai ser o mesmo nome da classe.

Em series-created.blade.php temos o componente de e-mail e vamos simplesmente chamá-lo "E-mail", 
por enquanto. Agora em SeriesCreated, podemos ir em view.name e chamar a view mail visto que está dentro da pasta mail e .series-create. 

/**
    * Build the message.
    *
    * @return $this
    */
public function build()
{
    return $this->view('mail.series-created');
}


Pronto, já temos o e-mail configurado e em series-created.blade.php podemos informar "Uma nova série foi criada." 
e poderíamos adicionar o link pedindo para conferir ou algo nesse sentido.
Série criada e queremos visualizar esse e-mail antes de enviar para garantir que está tudo certo, e como o e-mail por trás possui um HTML ou um texto, pelo menos, conseguimos visualizar no navegador. 
Então, vamos criar uma rota só para teste que vamos remover mais adiante em "routes > web.php" só para visualizar este e-mail.

Em web.php vamos inserir um Route:get('/email') e teremos um function() que vai retornar a classe de SeriesCreated(), visto que quando retornamos um e-mail o Laravel já sabe que ele deve fazer é pegar a view, simples assim.

Route::get('/email', function () {
    return new \App\Mail\SeriesCreated();
});

Agora vamos subir o servidor do artisan novamente no terminal, então, php artisan serve --host=0.0.0.0. Após finalizar, vamos à aplicação e acessar a URL "http://localhost:800/email" e será exibida a mensagem "Uma nova série foi criada". 

A princípio está tudo certo e dentro de series-created.blade.php podemos escrever o HTML do e-mail, mas, escrever e-mails não é uma tarefa tão simples, não é toda propriedade CSS que é aceita, às vezes um cliente de e-mail aceita uma propriedade que outro não, assim, pode ficar bonito no hotmail, mas não no gmail. 
Então, o Laravel nos traz alguns componentes já personalizados e testados para envio de e-mail. 

Se você quiser utilizar isso, vamos dar uma analisada rápida na Documentação do Laravel , nessa página já vamos entender sobre configurações, 
mas, no momento vamos analisar como usar markdown para as views dos e-mails em "Markdown Mailables". 

Quando criamos um e-mail usando markdown, além da facilidade de escrever no formato markdown que é um pouco mais simples que o HTML, 
mas enfim, além dessa facilidade conseguimos também usar alguns componentes do próprio Laravel, como o @component('mail::message'),
e vamos fazer exatamente isso.

Em SeriesCreated ao invés de usar o método view no e-mail vamos inserir o markdown, ou seja, 
vai identificar que esse arquivo de view que estamos criando não vai ser um HTML qualquer, vai estar no formato de markdown. 

/**
    * Build the message.
    *
    * @return $this
    */
public function build()
{
    return $this->markdown('mail.series-created');
}
}


@component('mail::message')
    Uma nova série foi criada.
@endcomponent

Com isso, se atualizarmos na aplicação com a URL "http://localhost:800/email" repare que está bem mais interessante, 
a mensagem foi para o meio da tela e claro, possui alguns detalhes do Laravel como a mensagem "2022 Laravel. All rights reserved."
que poderíamos nos preocupar com isso, mas para o nosso cenário isso é perfeito, visto que ele já cria um layout interessante para o e-mail e 
que vai funcionar para todos os clientes, já foi melhor testado.

Em series-created.blade.php podemos usar markdown, então, por exemplo, se quisermos criar uma lista vamos incluir os itens 1 e 2.

    series-created.blade:

@component('mail::message')

# Uma nova série foi criada.

- Item 1
- Item 2

@endcomponent

criado uma estrutura do nosos e-mail:

@component('mail::message')

# {{ $nomeSerie }} criada

A série {{ $nomeSerie }} com {{ $qtdTemporadas }} temporadas e {{ $episodiosPorTemporada }} episódios por temporada foi criada.

Acesse aqui: 

@component('mail::button', ['url' => route('seasons.index', $idSerie)])
    Ver série
@endcomponent

@endcomponent

Estamos usando várias variáveis, mas onde elas serão encontradas? 
Podemos utilizar tanto quando fazemos com uma view, passando os dados em um colchetes em SeriesCreated no return do function build() 
ou podemos ter as propriedades da classe de e-mail públicas, tudo que for público a view vai acessar, se for privado não. 

Então podemos, ou ter as propriedades públicas ou passar no return do function build(). 
Assim, vamos receber isso tudo e transformar em propriedades públicas, então, em public function __construct () 
teremos uma string que vai ser o nome da série, o ID da série,a quantidade de temporadas e episódios.

public function __construct(
        public string $nomeSerie,
        public int $idSerie,
        public int $qtdTemporadas,
        public int $episodiosPorTemporada,
    )


@component('mail::message')

# {{ $nomeSerie }} criada

A Série <strong>"{{ $nomeSerie }}"</strong> com <strong>"{{ $qtdTemporadas }}"</strong> Temporadas e <strong>"{{ $episodiosPorTemporada }}"</strong> Episódios <br><center><strong>Foi criada com Sucesso!</strong></center>.

@component('mail::button', ['url' => route('seasons.index', $idSerie)])
    Ver série
@endcomponent

@endcomponent


vimos também que para acessar informações na view de e-mail, temos duas opções. A primeira seria em SeriesCreated, no return() passar como qualquer outra view, por exemplo, 'nomeSerie' => '' e passar o nome da série que recebemos.

    Exemplo da primeira opção:

public function build()
    {
        return $this->markdown('mail.series-created'[
                'nomeSerie' => ''
                ]);
    }

A segunda opção é fazer como já está sendo usado no exemplo

dentro do controller SeriesController no metod store, uso da facade mail pra realizar o envio do email

$email = new SeriesCreated(
        $serie->nome,
        $serie->id,
        $request->seasonsQty,
        $request->episodesPerSeason,
);
Mail::to($request->user())->send($email);

Nessa classe Mail chamamos o método to() e informar para quem queremos enviar o e-mail, 
podemos enviar agora para o usuário logado, temos algumas formas de pegar o usuário logado, que já vimos, 
por exemplo, auth::user(): Mail::to(Auth::user())


Teoricamente, é isso que precisamos para enviar uma série por e-mail, só que quando vamos enviar um e-mail usando PHP, 
precisamos enviar de alguma forma. Pode ser utilizando a função mail() do PHP, o que ela faz é chamar um binário que temos que ter 
no sistema operacional, chamado sendmail, mas precisaríamos configurar no próprio servidor e computador.

ao invés de usar o sendmail é muito comum chamar algum servidor SMTP 
assim, podemos usar a nossa conta do gmail para enviar esse e-mail. 
Basta usar as credenciais SMTP que você consegue buscar no gmail e configurar. 

ao usar o SMTP e podemos passar as informações, o servidor SMTP, qual a porta, se vai usar criptografia, usuário e senha, enfim, 
podemos passar todas essas informações diretamente em SMTP ou, o que é mais correto, é usar as variáveis de ambiente. 

mas para ambiente de teste, pode ser ultilizado mailtrap
criar uma conta caso ainda não tenha, logado temos uma caixa de e-mail, em "My Inbox". Esse mailtrap é um serviço que intercepta 
todos os e-mails que enviamos, então, se configurarmos o servidor como sendo mailtrap e tentar enviar para o e-mail pessoal, 
esse e-mail não vai ser enviado e só vão cair nessa caixa. 

Então, isso é fenomenal para o ambiente de desenvolvimento e ainda já vemos como configurar o Laravel em um cenário real, 
visto que em ambiente de produção também utilizaríamos um SMPT para um servidor mais complexo ou um gmail, por exemplo. 

Exemplo de configuração de usuário do mailtrap:

MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=a61b0f38eef3a
MAIL_PASSWORD=5d7013d8c3e134
MAIL_ENCRYPTION=tls

as se quisermos ter um padrão, em .env que inserimos que todos os e-mails enviados pelo sistema são de "contato@example.com", então, MAIL_FROM_ADDRESS="contato@example.com" vai ser utilizado e o nome do remetente, de quem enviou que podemos colocar "Sistema de séries", mas ele está pegando o APP_NAME lá na linha 1, que no caso está sendo chamado de Laravel, vamos alterar para "Sistema de séries".

MAIL_FROM_ADDRESS="contato@example.com"
MAIL_FROM_NAME="APP_NAME"

como enviar a mesma estrutura de email para varios usuários, Basta


$userList = User::all();
/** varios usuarios */
foreach ($userList as $user) {
    Mail::to($user)->send($email);
}

porem irá apresentar error de repetição de envio de mail de usuarios, para correção

$userList = User::all();
foreach ($userList as $user) {
    /** envio de email */
    $email = new SeriesCreated(
        $serie->nome,
        $serie->id,
        $request->seasonQty,
        $request->episodesPerSeason
    );
    
    /** varios usuarios */
    Mail::to($user)->send($email);
}

por uso do mailtrap gratuito, possui um limite de 5 envio por a cada 10 segundos
Expected response code "354" but got code "550", with message "550 5.7.0 Requested action not taken: too many emails per second".
"solução" sleep(2)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aprendemos a criar classes Mailable com Laravel
Vimos como enviar e-mails utilizando Laravel
Aprendemos a enviar múltiplos e-mails sem problemas
Conhecemos a ferramenta mailtrap
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TOP 02

No capítulo anterior, aprendemos como enviar e-mails utilizando o Laravel, mas, com isso, gerou um problema de performance, dado que estamos fazendo o usuário 
esperar que o e-mail seja enviado e enviar e-mails tende a ser uma tarefa demorada, principalmente quando está sendo enviado seis e-mails e não apenas um. 
Mesmo sendo apenas um e-mail, notamos um problema de performance e conforme o número de e-mails enviados aumenta o problema também aumenta. 

Se queremos continuar enviando os e-mails individualmente e mesmo enviando apenas um é uma tarefa demorada, como podemos resolver o processamento de uma tarefa 
demorada sem prender o usuário? 
Podemos transformar isso em algo assíncrono, o conceito que vamos usar é o de mensageria

Mas, basicamente o que queremos fazer é ao invés de enviar um e-mail, queremos informar para o Laravel colocar esse e-mail em uma fila para depois dar uma 
olhada nessa fila e analisar quais e-mails tenho que enviar e enviar depois, sem ser nessa requisição, ou seja, enquanto o usuário está esperando.
Basicamente é esse o conceito de mensageria e como vamos implementar.

"Queueing Mail", ou seja, adicionando e enfileirando o e-mail. 

Então, ao invés de chamar o método send() chamar o método queue(), no código da documentação tem alguns detalhes de e-mail além do from que aprendemos sobre, 
temos o cc, bcc para adicionar cópia, cópia oculta, poderíamos trabalhar com anexo e entre outras funcionalidades. 
Mas o que vamos fazer é ao invés de enviar, vamos enfileirar esse e-mail.

Mail::to($user)->queue($email);

na verdade, ele está adicionando esse e-mail em uma fila que vai ser processada, só que o Laravel está configurado para processar o que entra na fila de 
forma síncrona.
Na prática, não mudou nada, é como se estivéssemos chamando o send(), a diferença é que agora o Laravel está tendo que fazer uma volta maior, já que está 
adicionando em uma fila e um outro código pega isso de uma fila e já processa, de forma síncrona e o que queremos é assíncrona.
Em "config > queue" vamos dar uma analisada nas configurações

repare que na linha 16 temos uma queue_connection, é como vamos usar para lidar com filas, então, podemos informar qual a conexão que vamos utilizar e 
em queue_connection o padrão é sync, ou seja, o Laravel vai ficar verificando se alguma tarefa foi adicionada na fila, já é processado de forma síncrona.

As possibilidades são: sync, database para utilizar o banco de dados como se fosse o sistema de mensageria, o beanstalkd que é uma ferramenta externa, 
o sqs que é o sistema de mensageria da Amazon, o redis que é um banco de dados de chave valor bem mais rápido, enfim. O que vamos usar no projeto por 
simplicidade é o database.

Em um cenário real, se estivesse na AWS, utilizaríamos o sqs, podemos usar o Kafka ou o RabbitMQ, então, configurariam e até usaríamos pacotes externos, 
para o cenário o database vai ser o suficiente. Então, no arquivo .env que é onde temos as configurações, o queue_connection é o sync, 
que vamos alterar para "database".

então alterar no .env
de QUEUE_CONNECTION=sync para QUEUE_CONNECTION=database
quando for executado o queue() ele vai adicionar essa informação em uma fila, então ele pega o e-mail e cria um registro em uma tabela de tarefas para 
processar e essas tarefas serão lidas depois

em seguida, selecionar o botão "Adicionar" novamente e temos um erro com a mensagem: "SQLSTATE[HY000]: General error: 1 no such table:jobs", 
já que a tabela para adicionar esses jobs (tarefas) não existe.
Nós poderíamos criar uma migration com todos os campos que aparecem abaixo do erro, como: "queue", "attempts", "reserved_at", "available_at", "created_at", 
"payload" e seus respectivos valores.

Mas,já temos alguns comandos para ajudar com isso, como o queue:table ele vai criar a migration que cria a tabela de jobs.
php artisan queue:table

Esse comando vai gerar uma migration, perceba no projeto do lado esquerdo da tela que foi criado um arquivo create_jobs_table.php, 
selecionando ele note que temos uma migration criada com tudo configurado da forma como o Laravel sabe trabalhar e no terminal vamos 
rodar o comando php artisan migrate.

vamos selecionar o botão "Adicionar" e repare que a resposta foi bem rápida. 
Só que esses e-mails existem e podemos visualizar acessando o banco de dados para verificar, em "database > database.sqlite" e agora que o banco de dados 
está preenchido, a tabela de jobs já possui essa tarefa, como podemos fazer para processar?.