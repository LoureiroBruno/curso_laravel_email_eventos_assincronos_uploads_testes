TOP 01

# php artisan make:mail nomedotipo
dentro de SeriesCreated temos uma classe qualquer, só que além de estender o Mailable ela também possui algumas traits que o Laravel nos fornece, 
no caso Queueable e SerializesModels.

A classe SeriesCreated estende um Mailable, isso significa que ela é enviável e possui alguns métodos como o view
também possui um construtor() para recebermos algum parâmetro que seja necessário, 
vamos utilizar e um build() que basicamente constrói o e-mail, define qual o template, se é preciso passar alguma coisa, 
se tiver alguma regra para criar esse e-mail podemos inserir nesse build(), mas isso normalmente não é necessário. 

Então, esse método view, return $this->view('view.name');, 
vai carregar um HTML e transformá-lo no e-mail que queremos enviar. Assim, 
vamos criar esse HTML em "resources > views" e em views vamos criar uma nova pasta de mail selecionando o botão direito do mouse nas opções "New > 
PHP File" e no campo "File name" inserir "mail/series-created.blade.php" que vai ser o mesmo nome da classe.

Em series-created.blade.php temos o componente de e-mail e vamos simplesmente chamá-lo "E-mail", 
por enquanto. Agora em SeriesCreated, podemos ir em view.name e chamar a view mail visto que está dentro da pasta mail e .series-create. 

/**
    * Build the message.
    *
    * @return $this
    */
public function build()
{
    return $this->view('mail.series-created');
}


Pronto, já temos o e-mail configurado e em series-created.blade.php podemos informar "Uma nova série foi criada." 
e poderíamos adicionar o link pedindo para conferir ou algo nesse sentido.
Série criada e queremos visualizar esse e-mail antes de enviar para garantir que está tudo certo, e como o e-mail por trás possui um HTML ou um texto, pelo menos, conseguimos visualizar no navegador. 
Então, vamos criar uma rota só para teste que vamos remover mais adiante em "routes > web.php" só para visualizar este e-mail.

Em web.php vamos inserir um Route:get('/email') e teremos um function() que vai retornar a classe de SeriesCreated(), visto que quando retornamos um e-mail o Laravel já sabe que ele deve fazer é pegar a view, simples assim.

Route::get('/email', function () {
    return new \App\Mail\SeriesCreated();
});

Agora vamos subir o servidor do artisan novamente no terminal, então, php artisan serve --host=0.0.0.0. Após finalizar, vamos à aplicação e acessar a URL "http://localhost:800/email" e será exibida a mensagem "Uma nova série foi criada". 

A princípio está tudo certo e dentro de series-created.blade.php podemos escrever o HTML do e-mail, mas, escrever e-mails não é uma tarefa tão simples, não é toda propriedade CSS que é aceita, às vezes um cliente de e-mail aceita uma propriedade que outro não, assim, pode ficar bonito no hotmail, mas não no gmail. 
Então, o Laravel nos traz alguns componentes já personalizados e testados para envio de e-mail. 

Se você quiser utilizar isso, vamos dar uma analisada rápida na Documentação do Laravel , nessa página já vamos entender sobre configurações, 
mas, no momento vamos analisar como usar markdown para as views dos e-mails em "Markdown Mailables". 

Quando criamos um e-mail usando markdown, além da facilidade de escrever no formato markdown que é um pouco mais simples que o HTML, 
mas enfim, além dessa facilidade conseguimos também usar alguns componentes do próprio Laravel, como o @component('mail::message'),
e vamos fazer exatamente isso.

Em SeriesCreated ao invés de usar o método view no e-mail vamos inserir o markdown, ou seja, 
vai identificar que esse arquivo de view que estamos criando não vai ser um HTML qualquer, vai estar no formato de markdown. 

/**
    * Build the message.
    *
    * @return $this
    */
public function build()
{
    return $this->markdown('mail.series-created');
}
}


@component('mail::message')
    Uma nova série foi criada.
@endcomponent

Com isso, se atualizarmos na aplicação com a URL "http://localhost:800/email" repare que está bem mais interessante, 
a mensagem foi para o meio da tela e claro, possui alguns detalhes do Laravel como a mensagem "2022 Laravel. All rights reserved."
que poderíamos nos preocupar com isso, mas para o nosso cenário isso é perfeito, visto que ele já cria um layout interessante para o e-mail e 
que vai funcionar para todos os clientes, já foi melhor testado.

Em series-created.blade.php podemos usar markdown, então, por exemplo, se quisermos criar uma lista vamos incluir os itens 1 e 2.

    series-created.blade:

@component('mail::message')

# Uma nova série foi criada.

- Item 1
- Item 2

@endcomponent

criado uma estrutura do nosos e-mail:

@component('mail::message')

# {{ $nomeSerie }} criada

A série {{ $nomeSerie }} com {{ $qtdTemporadas }} temporadas e {{ $episodiosPorTemporada }} episódios por temporada foi criada.

Acesse aqui: 

@component('mail::button', ['url' => route('seasons.index', $idSerie)])
    Ver série
@endcomponent

@endcomponent

Estamos usando várias variáveis, mas onde elas serão encontradas? 
Podemos utilizar tanto quando fazemos com uma view, passando os dados em um colchetes em SeriesCreated no return do function build() 
ou podemos ter as propriedades da classe de e-mail públicas, tudo que for público a view vai acessar, se for privado não. 

Então podemos, ou ter as propriedades públicas ou passar no return do function build(). 
Assim, vamos receber isso tudo e transformar em propriedades públicas, então, em public function __construct () 
teremos uma string que vai ser o nome da série, o ID da série,a quantidade de temporadas e episódios.

public function __construct(
        public string $nomeSerie,
        public int $idSerie,
        public int $qtdTemporadas,
        public int $episodiosPorTemporada,
    )


@component('mail::message')

# {{ $nomeSerie }} criada

A Série <strong>"{{ $nomeSerie }}"</strong> com <strong>"{{ $qtdTemporadas }}"</strong> Temporadas e <strong>"{{ $episodiosPorTemporada }}"</strong> Episódios <br><center><strong>Foi criada com Sucesso!</strong></center>.

@component('mail::button', ['url' => route('seasons.index', $idSerie)])
    Ver série
@endcomponent

@endcomponent


vimos também que para acessar informações na view de e-mail, temos duas opções. A primeira seria em SeriesCreated, no return() passar como qualquer outra view, por exemplo, 'nomeSerie' => '' e passar o nome da série que recebemos.

    Exemplo da primeira opção:

public function build()
    {
        return $this->markdown('mail.series-created'[
                'nomeSerie' => ''
                ]);
    }

A segunda opção é fazer como já está sendo usado no exemplo

dentro do controller SeriesController no metod store, uso da facade mail pra realizar o envio do email

$email = new SeriesCreated(
        $serie->nome,
        $serie->id,
        $request->seasonsQty,
        $request->episodesPerSeason,
);
Mail::to($request->user())->send($email);

Nessa classe Mail chamamos o método to() e informar para quem queremos enviar o e-mail, 
podemos enviar agora para o usuário logado, temos algumas formas de pegar o usuário logado, que já vimos, 
por exemplo, auth::user(): Mail::to(Auth::user())


Teoricamente, é isso que precisamos para enviar uma série por e-mail, só que quando vamos enviar um e-mail usando PHP, 
precisamos enviar de alguma forma. Pode ser utilizando a função mail() do PHP, o que ela faz é chamar um binário que temos que ter 
no sistema operacional, chamado sendmail, mas precisaríamos configurar no próprio servidor e computador.

ao invés de usar o sendmail é muito comum chamar algum servidor SMTP 
assim, podemos usar a nossa conta do gmail para enviar esse e-mail. 
Basta usar as credenciais SMTP que você consegue buscar no gmail e configurar. 

ao usar o SMTP e podemos passar as informações, o servidor SMTP, qual a porta, se vai usar criptografia, usuário e senha, enfim, 
podemos passar todas essas informações diretamente em SMTP ou, o que é mais correto, é usar as variáveis de ambiente. 

mas para ambiente de teste, pode ser ultilizado mailtrap
criar uma conta caso ainda não tenha, logado temos uma caixa de e-mail, em "My Inbox". Esse mailtrap é um serviço que intercepta 
todos os e-mails que enviamos, então, se configurarmos o servidor como sendo mailtrap e tentar enviar para o e-mail pessoal, 
esse e-mail não vai ser enviado e só vão cair nessa caixa. 

Então, isso é fenomenal para o ambiente de desenvolvimento e ainda já vemos como configurar o Laravel em um cenário real, 
visto que em ambiente de produção também utilizaríamos um SMPT para um servidor mais complexo ou um gmail, por exemplo. 

Exemplo de configuração de usuário do mailtrap:

MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=a61b0f38eef3a
MAIL_PASSWORD=5d7013d8c3e134
MAIL_ENCRYPTION=tls

as se quisermos ter um padrão, em .env que inserimos que todos os e-mails enviados pelo sistema são de "contato@example.com", então, MAIL_FROM_ADDRESS="contato@example.com" vai ser utilizado e o nome do remetente, de quem enviou que podemos colocar "Sistema de séries", mas ele está pegando o APP_NAME lá na linha 1, que no caso está sendo chamado de Laravel, vamos alterar para "Sistema de séries".

MAIL_FROM_ADDRESS="contato@example.com"
MAIL_FROM_NAME="APP_NAME"

como enviar a mesma estrutura de email para varios usuários, Basta


$userList = User::all();
/** varios usuarios */
foreach ($userList as $user) {
    Mail::to($user)->send($email);
}

porem irá apresentar error de repetição de envio de mail de usuarios, para correção

$userList = User::all();
foreach ($userList as $user) {
    /** envio de email */
    $email = new SeriesCreated(
        $serie->nome,
        $serie->id,
        $request->seasonQty,
        $request->episodesPerSeason
    );
    
    /** varios usuarios */
    Mail::to($user)->send($email);
}

por uso do mailtrap gratuito, possui um limite de 5 envio por a cada 10 segundos
Expected response code "354" but got code "550", with message "550 5.7.0 Requested action not taken: too many emails per second".
"solução" sleep(2)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aprendemos a criar classes Mailable com Laravel
Vimos como enviar e-mails utilizando Laravel
Aprendemos a enviar múltiplos e-mails sem problemas
Conhecemos a ferramenta mailtrap
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TOP 02

No capítulo anterior, aprendemos como enviar e-mails utilizando o Laravel, mas, com isso, gerou um problema de performance, dado que estamos fazendo o usuário 
esperar que o e-mail seja enviado e enviar e-mails tende a ser uma tarefa demorada, principalmente quando está sendo enviado seis e-mails e não apenas um. 
Mesmo sendo apenas um e-mail, notamos um problema de performance e conforme o número de e-mails enviados aumenta o problema também aumenta. 

Se queremos continuar enviando os e-mails individualmente e mesmo enviando apenas um é uma tarefa demorada, como podemos resolver o processamento de uma tarefa 
demorada sem prender o usuário? 
Podemos transformar isso em algo assíncrono, o conceito que vamos usar é o de mensageria

Mas, basicamente o que queremos fazer é ao invés de enviar um e-mail, queremos informar para o Laravel colocar esse e-mail em uma fila para depois dar uma 
olhada nessa fila e analisar quais e-mails tenho que enviar e enviar depois, sem ser nessa requisição, ou seja, enquanto o usuário está esperando.
Basicamente é esse o conceito de mensageria e como vamos implementar.

"Queueing Mail", ou seja, adicionando e enfileirando o e-mail. 

Então, ao invés de chamar o método send() chamar o método queue(), no código da documentação tem alguns detalhes de e-mail além do from que aprendemos sobre, 
temos o cc, bcc para adicionar cópia, cópia oculta, poderíamos trabalhar com anexo e entre outras funcionalidades. 
Mas o que vamos fazer é ao invés de enviar, vamos enfileirar esse e-mail.

Mail::to($user)->queue($email);

na verdade, ele está adicionando esse e-mail em uma fila que vai ser processada, só que o Laravel está configurado para processar o que entra na fila de 
forma síncrona.
Na prática, não mudou nada, é como se estivéssemos chamando o send(), a diferença é que agora o Laravel está tendo que fazer uma volta maior, já que está 
adicionando em uma fila e um outro código pega isso de uma fila e já processa, de forma síncrona e o que queremos é assíncrona.
Em "config > queue" vamos dar uma analisada nas configurações

repare que na linha 16 temos uma queue_connection, é como vamos usar para lidar com filas, então, podemos informar qual a conexão que vamos utilizar e 
em queue_connection o padrão é sync, ou seja, o Laravel vai ficar verificando se alguma tarefa foi adicionada na fila, já é processado de forma síncrona.

As possibilidades são: sync, database para utilizar o banco de dados como se fosse o sistema de mensageria, o beanstalkd que é uma ferramenta externa, 
o sqs que é o sistema de mensageria da Amazon, o redis que é um banco de dados de chave valor bem mais rápido, enfim. O que vamos usar no projeto por 
simplicidade é o database.

Em um cenário real, se estivesse na AWS, utilizaríamos o sqs, podemos usar o Kafka ou o RabbitMQ, então, configurariam e até usaríamos pacotes externos, 
para o cenário o database vai ser o suficiente. Então, no arquivo .env que é onde temos as configurações, o queue_connection é o sync, 
que vamos alterar para "database".

então alterar no .env
de QUEUE_CONNECTION=sync para QUEUE_CONNECTION=database
quando for executado o queue() ele vai adicionar essa informação em uma fila, então ele pega o e-mail e cria um registro em uma tabela de tarefas para 
processar e essas tarefas serão lidas depois

em seguida, selecionar o botão "Adicionar" novamente e temos um erro com a mensagem: "SQLSTATE[HY000]: General error: 1 no such table:jobs", 
já que a tabela para adicionar esses jobs (tarefas) não existe.
Nós poderíamos criar uma migration com todos os campos que aparecem abaixo do erro, como: "queue", "attempts", "reserved_at", "available_at", "created_at", 
"payload" e seus respectivos valores.

Mas,já temos alguns comandos para ajudar com isso, como o queue:table ele vai criar a migration que cria a tabela de jobs.
php artisan queue:table

Esse comando vai gerar uma migration, perceba no projeto do lado esquerdo da tela que foi criado um arquivo create_jobs_table.php, 
selecionando ele note que temos uma migration criada com tudo configurado da forma como o Laravel sabe trabalhar e no terminal vamos 
rodar o comando 
# php artisan migrate.

vamos selecionar o botão "Adicionar" e repare que a resposta foi bem rápida. 
Só que esses e-mails existem e podemos visualizar acessando o banco de dados para verificar, em "database > database.sqlite" e agora que o banco de dados 
está preenchido, a tabela de jobs já possui essa tarefa, como podemos fazer para processar?.

Então, a série foi adicionada e nenhum e-mail foi enviado ainda, no mailtrap temos o inbox vazio. 
Então, queremos verificar se os jobs foram incluídos em algum lugar, ou seja, se estão prontos para serem processados e ver como processá-los. 
poderíamos verificar essas tarefas (jobs) no banco de dados, mas vamos abrir um novo terminal e rodar o comando 
# php artisan tinker
que abre um terminal interativo parecido com o do "php -a" só que nesse ele já carrega o Laravel e inicializa a aplicação, 
ou seja, temos acesso a tudo que teríamos acesso no controller, por exemplo, e isso nos facilita bastante.

Exemplificando, podemos efetuar um select no terminal usando a facade de banco de dados, que vai retornar todos os registros da tabela de jobs.

DB::select('select * from jobs;');
Então, temos nesse select as seis tarefas de envio de e-mail, assim, uma tarefa tem o ID, em queue qual a fila e o Laravel consegue trabalhar com 
várias filas e no payload temos algumas informações como o ID do job, que é a tarefa que vai ser executada, o display name que é o nome da tarefa 
e a queue exatamente o que vai ser executado, temos o comando que vai ser rodado para enviar um e-mail na fila. Temos todas as informações.

Só um detalhe, dentro do tinker podemos acessar qualquer código mesmo, não somente o DB, por exemplo, se quisermos pegar todos os usuários, \App\Models\User::all();, 
conseguimos acessar as models. 

Mas agora vamos sair do tinker usando o comando quit no terminal e limpar a tela com o clear e analisar como podemos processar esses e-mails. 
Então, se no terminal rodarmos php artisan temos duas formas: uma delas é o queue:listen e a outra o queue:work, 
ambas são semelhantes, 
mas, 
por regra, em produção, utilizamos o queue:work, que pega todo o código Laravel e insere em memória, inicia a aplicação uma única vez e fica ouvindo todas as 
tarefas que vão entrando na fila, ou seja, 
se em algum momento for alterado o código e gerar uma tarefa esse work que vai estar rodando, não pega o código atualizado, então, em tempo de desenvolvimento 
é comum usar o listen. 

Em desenvolvimento usamos o queue:listen visto que sempre que chega uma nova tarefa o Laravel é inicializado e o queue:work é usado em produção 
por ser mais rápido, ele inicializa o Laravel uma vez só. Por estarmos habituado vou usar sempre o work.

No terminal vamos rodar o 
# php artisan queue:work 
e, com isso, vai começar a processar os jobs, está enviando e falhou no sexto, o motivo já sabemos, 
o mailtrap tem o limite de cinco e-mails a cada dez segundos.

Então, para resolver esse problema vamos conferir e garantir que os cinco e-mails foram enviados no mailtrap, foram enviados e isso significa que as tarefas 
estão sendo processadas, 
logo, os e-mails estão sendo enviados. Agora, vamos interromper o work no terminal e revisar.

quando trabalhamos com o conceito de mensageria ou filas de mensagens, temos um produtor de mensagem e um consumidor.
O produtor, no caso, é o próprio sistema web, ele está enviando uma mensagem adicionando algo na fila para ser processado depois e temos um processo 
consumidor que vai ser inicializado com o queue:work, ou seja, são dois processos separados, o servidor web está em um terminal e o consumidor (worker de filas)
está em outro.

Revisado esse conceito, vamos analisar o que aconteceu e encontrar o job que falhou. Vamos abrir o tinker, 
# php artisan tinker 
e executar novamente o 
# DB::select('select * from jobs;'); 
a tabela de jobs retorna vazia, então, para garantir que vamos encontrar o job que falhou, podemos visualizar na tabela de failedjobs, 
temos essa tabela que armazena todas as tarefas que não ocorreram com sucesso.
DB::select('select * from failed_jobs;');
listando as tarefas que não foi executada com sucesso.

Se quisermos tentar executar novamente esse job, vamos ter que sair do tinker usando o comando quit, rodar o php artisan para ver a lista de comandos e em queue
temos um retry que tenta rodar alguma tarefa novamente. Só que o queue:retry espera alguns parâmetros, no terminal vamos rodar o comando 
# php artisan queue:retry --help 
e um desses parâmetros é o "id" do job que queremos tentar novamente. 

Se quisermos todos os jobs que falharam, podemos passar ao invés de um "id" o parâmetro all, então, ficaria 
# php artisan queue:retry "all". 
Mas queremos apenas um job, podemos acessar o banco de dados e copiar o id do job ou simplesmente rodar o comando 
# php artisan queue:failed 
que já nos mostra os jobs que falharam e copiar o "ID" que aparece na tabela para fazer o retry.

# php artisan queue:retry 895d14e0-dc78-450c-bf89-b281bf9f98fc

vamos tentar o retry desse job selecionando o "enter" e repare que não é processado, ele adiciona novamente esse job na fila já que temos um worker que 
está processando isso tudo, vamos subir esse processo de novo, php artisan queue:work

criar uma verficação em caso de falha

Qual a diferença entre os comandos queue:listen e queue:work?
Quando executamos o comando 
# php artisan queue:work 
nossa aplicação Laravel é carregada em memória e fica rodando “para sempre” esperando novos processos serem adicionados à fila. 
Sempre que alteramos o código devemos interromper o comando e rodá-lo de novo, ou executar 
# php artisan queue:restart 
para reiniciar o worker. 
Já o 
# php artisan queue:listen 
recarrega a aplicação a cada processo da fila que for processar, o que é menos eficiente. 
Normalmente usamos listen em desenvolvimento e work em produção.

vimos como buscar quais jobs falharam, tanto dentro do tinker quanto rodando o queue:failed e aprendemos como tentar novamente as tarefas que falharam, 
após a análise. 
no caso:
# php artisan queue:retry "all"
# php artisan queue:worker
# php artisan serve

Normalmente essa tabela de jobs ou outros mecanismos para encontrar as tarefas que falharam deve ser utilizada para identificar um problema desconhecido 
e corrigir no código. 

nosso cenário é um problema conhecido, então não devemos deixar ele cair nessa failed jobs precisamos implementar algum mecanismo para corrigir isso

podemos utilizar o parâmetro tries, por exemplo, igual a dois, isso significa que vamos tentar duas vezes antes de adicionar esse job na tabela de 
tarefas que falharam. 
Então, estamos tentando enviar um e-mail, deu tudo certo? Sim, logo vamos para o próximo, senão, tente novamente e se falhar de novo, aí sim, adicione na 
tabela de tarefas que falharam

Contudo, se tentarmos duas vezes na mesma hora a probabilidade dele falhar de novo é bem grande, assim, vamos adicionar um delay (em português, atraso) 
entre uma tentativa e outra. Para isso, é preciso usar o parâmetro delay e no caso será dez segundos.

# php artisan queue:work --tries=2 --delay=10

Esses parâmetros conseguimos visualizar executando o comando php artisan queue:work --help, note que temos o delay que é o número de segundos para atrasar os 
jobs que falharam e o tries que informa o número de tentativas que vai ser executado até enviar para a tabela de tarefas falhadas. 

Vamos inicializar esse worker e não existe nenhum job para processar, então, vamos voltar para a aplicação, remover a série "Outra" clicando no botão "X" 
e selecionar o botão "Adicionar" para inserir uma nova série chamada "Outra" com uma temporada, um episódio e novamente clicar no botão "Adicionar".

Repare que a resposta foi rápida e no mailtrap está sendo processado o envio, o sexto provavelmente falhou, se formos ao terminal ele ainda não finalizou o 
processamento, está como "processing" visto que ele vai executar o retry, daqui a alguns segundos vai ser exibida a finalização, pronto, agora foi 
processado, está como "processed" no terminal.

No mailtrap todos os e-mails chegaram, essa é uma solução. Mas essa forma não é a ideal, não é interessante que fiquemos dependentes que o processo de 
worker saiba que precisa esperar uma quantidade de segundos específicos, não é uma boa forma de resolver o problema. 

vamos encerrar o worker e até podemos usar esse mecanismo de tries, podemos ter um delay se fizer sentido para a aplicação, mas não se for para um detalhe 
específico como é o caso do mailtrap.

Para esse cenário, podemos utilizar em SeriesController outra função além da queue() que é o later(), este é igual ao queue() só que ao invés de receber 
somente o e-mail que vai ser enviado ele espera o momento em que isso será executado além do e-mail. agendando a atividade a ser executada.

Então, esse momento que vai ser executado pode ser um datetime, podemos criar, por exemplo, $now = newnDateTime(); e adicionar no now dois segundos a cada e-mail.

$when = new DateTime();
$when->modify($index * 2 . 'seconds');
Mail::to($user)->later($when, $email);

Só que esses dois segundos, vamos acabar adicionando para todos os e-mails que vai ser processado, 
foreach pegar o índice do usuário, assim, se for o primeiro e-mail que estamos enviando espera dois segundos, se for o segundo usuário espera 
quatro segundos e assim por diante.

foreach ($userList as $index => $user) 

Contudo, isso depende de alguma interface de manipulação de data do PHP e o Laravel trás algumas facilidades para manipular datas também, então, 
vamos usar essas facilidades, podemos remover o 
$when->modify($index * 2 . 'seconds'); 
e o 
new DateTime(); 
para incluir a função now() que retorna um objeto que se parece um datetime e podemos acrescentar um addSeconds() para incluir o índice multiplicado pelo 
número dois, fica um pouco mais interessante, depende de menos conhecimento da API do PHP.

$when = now()->addSeconds($index * 2);
Mail::to($user)->later($when, $email);

mas para garantir que então esses dois segundos não foram o suficiente visto que porque pode bater certo nos dez segundos o e-mail foi enviado muito rápido.

$when = now()->addSeconds($index * 5);
Mail::to($user)->later($when, $email);

agregado a esta nova execução, no lado do consumo 
# php artisan queue:work --tries=2. 
com apenas o número de tentaivas sem a espera de qunado executar novamente na tratativa de error.

+++

public function store(SeriesFormRequestCreate $request)
{
    // dd($request->seasonQty);
    /**injeção de dependência - retornar o objeto SeriesRepository criado */
    $serie = $this->repository->add($request);

    $userList = User::all();
    // foreach ($userList as $user) {
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $serie->nome,
            $serie->id,
            $request->seasonQty,
            $request->episodesPerSeason
        );
        
        /** varios usuarios de forma síncrona*/
        // Mail::to($user)->send($email);
        // sleep(2);

        /** varios usuarios de forma assíncrona*/
        // Mail::to($user)->queue($email);

        /** varios usuarios de forma assíncrona*/
        /** com uso do later para agendar a execute */
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }
    
    /** unico usuário*/
    // Mail::to($request->user())->send($email);

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}

+++

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aprendemos a adiar o envio do e-mail
Vimos como configurar as filas de processos no banco de dados
Aprendemos a executar os processos agendados em fila
Entendemos como definir o horário de execução de um processo
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TOP 03

public function store(SeriesFormRequestCreate $request)
{
    // dd($request->seasonQty);
    /**injeção de dependência - retornar o objeto SeriesRepository criado */
    $serie = $this->repository->add($request);

    

    $userList = User::all();
    // foreach ($userList as $user) {
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $serie->nome,
            $serie->id,
            $request->seasonQty,
            $request->episodesPerSeason
        );
        
        /** varios usuarios de forma síncrona*/
        // Mail::to($user)->send($email);
        // sleep(2);

        /** varios usuarios de forma assíncrona*/
        // Mail::to($user)->queue($email);

        /** varios usuarios de forma assíncrona*/
        /** com uso do later para agendar a execute */
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }
    
    /** unico usuário*/
    // Mail::to($request->user())->send($email);

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}

mesmo metodo sem comentários - método enxuto

public function store(SeriesFormRequestCreate $request)
{
    $serie = $this->repository->add($request);

    $userList = User::all();
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $serie->nome,
            $serie->id,
            $request->seasonQty,
            $request->episodesPerSeason
        );
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}

-------------------------------------------------------------------------------------------------------------
guardar
-------------------------------------------------------------------------------------------------------------

então a idéia e desvincular a atribuição do método store dentro do controller respectivo, as filas de trabalho de envio de emails,  Além de armazenar uma 
série usando o repositório ou dependência já bem configurada, também está notificando todos os usuários.

public function store(SeriesFormRequestCreate $request)
{
    $serie = $this->repository->add($request);

    $userList = User::all();
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $serie->nome,
            $serie->id,
            $request->seasonQty,
            $request->episodesPerSeason
        );
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}

Para quem já realizou o curso de SOLID, sabe que deveríamos evitar ter múltiplas responsabilidades e o ideal é que a classe ou método tenha apenas um motivo 
para ser alterado. Então nessa parte do código que estamos comunicando o usuário se modificarmos a forma de notificar, como vamos enviar o e-mail, por exemplo, 
adicionando mais delay ou algo nesse sentido, vamos precisar alterar essa classe. Se precisar adicionar em outro repositório, também.
Assim, podemos começar a melhorar esse código. 
A criação da série, $serie = $this->repository->add($request); vai permanecer no arquivo SeriesController, mas, amos informar que uma série foi criada, então, 
alguém pode executar alguma ação com essa série criada. Basicamente, queremos gerar um evento e para gerar esse evento e alguma coisa acontecer, 
precisamos ter alguém aguardando ou ouvindo esse evento. Então, vamos criar um event listener. 

mas antes, interromper o worker e rodar o 
# php artisan queue:listen --tries=2 
para não precisar ter que ficar encerrando o worker e subindo novamente

# php artisan make:listener EmailUsersAboutSeriesCreated
é a classe que vamos criada que vai ser o ouvinte de evento, isto é, vai receber o evento e executar alguma coisa.

Após criar o event listener e ir para a classe criada no projeto, em "app > Listeners > EmailUsersAboutSeriesCreated", 
quando esse listener for ser executado vai receber um evento, que ainda vamos criar, mas, sabemos que esse evento vai precisar ter as informações necessárias para enviar o e-mail.

Assim, vamos voltar para o SeriesController e recortar o código de notificação do usuário e colar no arquivo EmailUsersAboutSeriesCreated dentro de public function handle()

/**
* Handle the event.
*
* @param  object  $event
* @return void
*/
public function handle($event)
{
$userList = User::all();
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $event->seriesName,
            $event->seriesId,
            $event->seriesSeasonsQty,
            $event->seriesEpisodesPerSeason
        );
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }
}

Esse evento que vamos receber que ainda não criamos, vai ter acessível todas as propriedades - seriesName, seriesId, seriesSeasonsQty e seriesEpisodesPerSeason - 
e a partir delas vamos conseguir criar o e-mail, e desse e-mail criado obter o envio. Por enquanto não estamos enviando e sim adicionando a uma fila. 

** Vamos recapitular o que estamos implementando na prática antes de criar o evento. 
Em SeriesController temos o método store() que vai armazenar uma série, ao criar uma série o que estávamos fazendo antes é chamando o repositório, isso é uma responsabilidade e envie os e-mails, 
outra responsabilidade. 
Imagine que mais para frente queremos executar um log quando essa série for criada, 
e além de e-mail enviar um SMS ou uma mensagem no Slack, 
ficaríamos adicionando código no método e isso não é uma boa prática.

** entao o mais corretto é
a fazer é desacoplar a ideia de criar uma série com qualquer outra coisa que resulte disso. Criar uma série é o que o método public function store(SeriesFormRequest $request) tem que fazer, 
por isso está chamando o repositório. 
Mas se outra coisa precisa acontecer além da criação, vamos remover desse método.
Para isso, vamos lidar com o conceito de eventos, é parecido com o que aprendemos de observable no treinamento de design patterns, o que teremos é uma classe que vai ser executada quando determinado
evento acontecer e um evento possui os dados, assim, esse evento tem as informações do evento que aconteceu. 
O evento que vamos criar é de uma nova série, então, esse evento vai possuir o nome da série, o ID da série, a quantidade de temporadas e quantidade de episódios por temporada. A partir disso, 
podemos adicionar os e-mails na fila ou qualquer poutro evento apartir dos dados obtidos desse ouvidor EmailusersAboutSeriesCreated para serem processados depois, com outro exemplo um log.

** já temos o listener e agora vamos criar o evento que iremos utilizar
# php artisan make:event SeriesCreated

No projeto em "app > Events > SeriesCreated" vamos ver o que temos nesse evento, a princípio não temos nada, podemos usar o broadcastOn() para ter canais de eventos, mas não vamos precisar 
disso e implementar de uma maneira mais simples. 
No construtor() vamos receber os parâmetros que contém os dados desse evento, repare que no listener EmailUsersAboutSeriesCreated esperamos que existam esses dados - seriesName, seriesId, 
seriesSeasonsQty e seriesEpisodesPerSeason.

/**
    * Handle the event.
    *
    * @param  object  $event
    * @return void
    */
public function handle($event)
{
    $userList = User::all();
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $event->seriesName,
            $event->seriesId,
            $event->seriesSeasonsQty,
            $event->seriesEpisodesPerSeason
        );
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }
}

Só que ao invés de um object (e-mail) sabemos que esse evento é um SeriesCreated

use App\Events\SeriesCreated as SeriesCreatedEvent;
use App\Mail\SeriesCreated;

/**
    * Handle the event.
    *
    * @param  object  $event
    * @return void
    */
public function handle(SeriesCreatedEvent $event)
{
    $userList = User::all();
    foreach ($userList as $index => $user) {
        /** envio de email */
        $email = new SeriesCreated(
            $event->seriesName,
            $event->seriesId,
            $event->seriesSeasonsQty,
            $event->seriesEpisodesPerSeason
        );
        $when = now()->addSeconds($index * 5);
        Mail::to($user)->later($when, $email);
    }
}

e add no Events/SeriesCreated

/**
    * Create a new event instance.
    *
    * @return void
    */
public function __construct(
    public readonly string $seriesName,
    public readonly int $seriesId,
    public readonly int $seriesSeasonsQty,
    public readonly int $seriesEpisodesPerSeason,
)
{
    //
}


Recapitulando, voltando para o listener o método handle() é executado quando um evento acontece e recebemos esse evento por parâmetro, 
o evento precisa possuir alguns dados, então, todas as informações do evento estamos adicionando no construtor de SeriesCreated. 
O construtor do evento SeriesCreated espera todos os dados que precisamos, que vão ser lidos no listener, esses dados estão como public readonly que significa que são acessíveis para qualquer pessoa, 
mas só podem ser escritos uma vez. Então, após a construção esse objeto não pode alterar mais as propriedades.

O evento foi criado e agora para emitir esse evento vamos para SeriesController no método store() e pegar o evento Series Created e chamar o dispatch(), que envia o evento para o Laravel. 
Estamos disparando o evento "\App\Events\SeriesCreated" e esperamos que o listener seja executado, teoricamente, o e-mail vai ser enviado. 
O dispatch()recebe por parâmetro tudo que o SeriesCreated receberia, então, para facilitar podemos adicionar o $seriesCreatedEvent = new \App\Events\SeriesCreated() que espera o nome da série,
o ID, a quantidade de temporadas e número de episódios por temporada, teoricamente temos todos os dados. 

Novamente, se não quisermos precisar da linha event($seriesCreatedEvent) podemos remover, apagar também o $seriesCreatedEvent = new e simplesmente chamar o dispatch() com os mesmos parâmetros.

public function store(SeriesFormRequestCreate $request)
{
    $serie = $this->repository->add($request);
    /** listener */
    \App\Events\SeriesCreated::dispatch(
        $serie->nome,
        $serie->id,
        $request->seasonsQty,
        $request->episodesPerSeason,
    );

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}


Agora sim, temos um objeto sendo dispatch, ou seja, enviado e o listener está pronto para ser executado também. No mailtrap vamos limpar a caixa de e-mail no ícone de carta com um "X" 
na parte superior e na aplicação vamos atualizar e adicionar uma série chamada "Teste", com uma temporada e um episódio, agora só selecionar o botão "Adicionar".

Aparece a mensagem que a série "teste" foi adicionada com sucesso, se formos no mailtrap percebemos que os e-mails não estão sendo enviados. Vamos ver o que aconteceu no work, se tivesse 
algo para ser processado seria mostrado, mas repare que no terminal ele não está tentando processar nada. 

Isso está acontecendo porque fizemos o dispatch(), mas o código do listener não foi executado, pois, como o Laravel vai saber que queremos executar um método da classe EmailUsersAboutSeriesCreated 
quando o evento SeriesCreated do arquivo SeriesController for gerado? Ele não sabe, então precisamos gerar essa configuração.


** Antes de implementar mais coisas, vamos recapitular o que já fizemos. 
Nós agora estamos desacoplando o SeriesController de qualquer outra tarefa que precisa acontecer quando uma série for criada, então, estamos criando a série e informando, apenas isso. 
Se alguma outra tarefa precisa acontecer é outro código que vai executar essa ação, como, notificar todos os usuários que a série foi criada, se quiséssemos realizar um log ou alguma ação nesse sentido.
momento temos o evento SeriesCreated que está sendo gerado quando criamos a série e um listener no arquivo EmailUsersAboutSeriesCreated pronto para ser executado com um método handle(). 
Mas, precisamos informar para o Laravel que sempre que o evento SeriesCreated for criado é para executar o listener. 

Para isso, vamos utilizar um service provider que o próprio Laravel possui por padrão em "app > Providers > EventServiceProvider", o EventServiceProvider contém uma propriedade chamada listen

/**
* The event to listener mappings for the application.
*
* @var array<class-string, array<int, class-string>>
*/
protected $listen = [
    Registered::class => [
        SendEmailVerificationNotification::class,
    ],

    SeriesCreated::class => [
        EmailUsersAboutSeriesCreated::class,
    ],
];

Então, vamos adicionar no listen o mapeamento de SeriesCreated que é o evento, importado do namespace correto que vai possuir apenas um listener, por enquanto, 
o EmailUsersAboutSeriesCreated. Com isso, o Laravel vai saber que sempre que a série for criada, o listener EmailUsersAboutSeriesCreated vai ser executado.

vamos criar um novo listener, então no terminal vamos encerrar o artisan serve com o comando ^C e rodar php artisan make:listener LogSeriesCreated, vai realizar
o log de uma série criada e podemos passar um parâmetro -e informando qual evento esse listener vai ouvir, no caso SeriesCreated.
# php artisan make:listener LogSeriesCreated -e SeriesCreated

No projeto, em "app > Listeners > LogSeriesCreated" temos já criado o novo listener que em handle() vamos inserir um log, o SeriesCreated possui o "seriesName, logo, já temos o evento e 
faremos um log disso, que está no namespace de facades também, temos uma facade de log no Laravel com vários métodos, o que vamos usar é o info, pois é um log informativo. 
Agora estamos realizando esse log, e precisamos adicionar também no EventServiceProvider esse novo listener LogSeriesCreated.
O que queremos garantir é que os e-mails não estejam sendo enviados visto que o worker não está rodando e que o log não esteja sendo criado e vamos ver o que vai acontecer.

** realizado um novo teste
"Adicionar" para criar uma nova série que vamos chamar de "Outra" com uma temporada, um episódio e novamente clicar no botão "Adicionar", vai ser exibida a mensagem informando que
a série "Outra" foi criada com sucesso.
esperado é que nenhum e-mail seja enviado, então, vamos para o mailtrap ver se chegou algum, não chegou. Esperamos também que o log não tenha sido salvo, então no arquivo laravel.log 
foi criado um log "local.INFO: Série Outra criada com sucesso".  

Isso significa que os eventos não estão entrando na fila, os eventos estão sendo executados de forma síncrona. Se quisermos que sejam desempenhados de maneira assíncrona, 
basta irmos no listener LogSeriesCreated e implementar um ShouldQueue.

class LogSeriesCreated implements ShouldQueue

Então, vamos rodar o php artisan queue:clear --help e podemos passar alguns parâmetros, como, por exemplo, qual a conexão, porém isso tudo é opcional, se simplesmente rodarmos um 
# php artisan queue:clear, 
vai limpar da tabela padrão.
pois foi realizado o teste e esta pendende o envio dos emails na tabela jobs


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aprendemos a trabalhar com eventos
Entendemos as vantagens de separar nosso código em event listeners
Vimos como trabalhar com eventos de forma síncrona e assíncrona
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------